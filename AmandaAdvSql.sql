select * from mydust

select * from salesrep
select * from sales

select * from students
select * from seminar
select * from course
select * from register


--Indexes p 11

create index lastnameind on employee(lastname) 

create index qtyind on mydust(quantity desc)

--marking primary key will keep a user from adding a duplicate field

create unique index corpind on employee(corpid)

--test, won't let you due to duplicates in this field. could use a nonunique index.
create unique index pnind on mysales(partnum)

--composite or multi-field index
create index nameind on employee(lastname, firstname)

sp_help


select * from sysindexes --shows all the indexes

drop index employee.corpind 

-- add PK at create table command

create table inventory
(partnum CHAR(6) primary key, --can't be null. normally allowed unless PK, not null)
descrip Char(13),
automake char(4),
quantity smallint,
price numeric(6,2))


select * from inventory
sp_help inventory

--PK: no dupes, no null, all are indexes but not all indexes are PKs, index and constraint. Has a funky name but it only matters if you want to drop it.

create table inv2
(partnum CHAR(6) constraint pk_partnum PRIMARY KEY,--how you name the pk index rather than autogenerated
descrip Char(13),
automake char(4),
quantity smallint,
price numeric(6,2))

sp_help inv2

--multifield primary key. both will be not nullable
create table PartSales
(Partnum char(6),
Qty_cold smallint,
Customer char(30),
Saledate smalldatetime,
CONSTRAINT PK_sales PRIMARY KEY (saledate, partnum) )

sp_help PartSales


--using alter table to add pk to existing tables
--first check for duplicates in the field you want to make primary. Nothing comes back - that is good!

select empnum, count(empnum)
from salesrep
group by empnum
having count(empnum) > 1
-- before adding PK, must make sure the field has a not-nullable setting. If it was nullable, you would use:

/* alter table salesrep
alter column empnum char(3) not null
have to repeat every piece of info to change nullable field*/

sp_help salesrep


alter table salesrep
add constraint pk_empnum primary key (empnum)
-- use this to add with a name

alter table salesrep
add primary key (empnum)
--use this to add with auto generated name

--can't have duplicate pk names

--Foreign keys p 18

create table partsales2
(partnum char(6) constraint fk_partsales2_partnum --optional to name
references inventory (partnum), --must have to add fk
qty_sold smallint,
customer char(30),
saledate smalldatetime)


--can add multiple fks for multiple tables in the create table statement. fails first due to orphan record 4. delete and then run.

alter table sales
add constraint fk_sales_empnum foreign key (empnum) references salesrep (empnum)

--notice diff syntax for existing field

delete from sales
where empnum = '004'

--pg 20 on delete or on update

-- exercise 2 p 22

select * from employee

select * from dependents


alter table employee
add primary key (id)


alter table dependents
add primary key (empid, depname)


alter table dependents
add foreign key (empid) references employee (id)


select * from mydust
select * from mysales

alter table mydust
add primary key (partnum)

alter table mysales
add foreign key (partnum) references mydust (partnum)

select * from burgers

--Referential integrity p 23

--modify fk p 25 - cascade updates/deletes. 4 options on update or delete - no action, cascade, set null, set default

select * from employee
select * from absent

sp_help absent
sp_help employee

alter table absent
add foreign key (id) references employee (id)
on delete cascade

delete from employee where id = 'A0020'

-- drop fk
alter table absent
drop constraint FK__absent__id__1DE57479

--make sure child field is nullable

alter table absent
alter column id char(5) null

--reconnect absent to employee with null not delete
alter table absent
add foreign key (id) references employee (id)
on delete set null

--test by deleting

delete from employee where id = 'A0019'

--ex 3 p29
select * from seminar
select * from course
select * from register
select * from students



alter table seminar
add primary key (semcode)

alter table course
add primary key(progcode)


alter table course
add foreign key (semcode) references seminar (semcode)


alter table register
add primary key (progcode, stunum)

alter table register
add foreign key (progcode) references course (progcode)
on delete cascade
on update cascade

alter table students
add primary key (stunum)

alter table register
add foreign key (stunum) references students (stunum)
on delete cascade 
on update cascade

update seminar set semcode = 'cm999' where semcode = 'cm101'
--doesn't work b/c of pk/fk

select * from course
select * from register

delete from course where progcode = 'a1007'
--deleted in both tables

update students set stunum = '111111' where stunum = '331372'

select * from students
select * from register
--updated both due to cascade


update register set stunum = '222222' where stunum = '371314'
--not allowed bc of constraints - can't change in child and affect parent



--union is not a relationship connection (p30). stack of papers, or  a pile of data
select * from mysales where customer = 'Smith''s Auto Repair'
UNION
Select * from oldsales
where customer = 'Smith''s Auto Repair'
order by saledate

select partnum, sum(qty_sold) from mysales group by partnum
UNION
select partnum, sum(qty_sold) from oldsales group by partnum

select saledate, partnum, customer into allsales
from mysales
union
select saledate, partnum, customer from oldsales

select * from allsales

select * into nov05sales
from mysales
where saledate between '11-01-05' and '11-30-05'

select * from nov05sales

select firstname, lastname, add1, add2, city, statecode, zip
into Not_Students from maillist
except
select firstname, lastname, addr1, addr2, city, statecode, zip from students

select * from not_students

insert into oldsales
select * from mysales
except
select * from oldsales


--intersect returns any distinct values from both select statements
--union removes duplicates by default. can use UNIONALL
--union must line up or things will be under wrong header - uses first header
-- can use an order by to rearrange unions

select * from students
select * from employee

--ex 4 p 37

select firstname, lastname, addr1, addr2, city, statecode, zip from students
union
select firstname, lastname, add1, add2, city, statecode, zip from employee
order by zip

select * from repsales
select * from atrans

select saledate, salesrep_code, amount from repsales
union
select invdate, salesid, sales from atrans


select * from mydust
select * from south

select partnum, descrip, automake from mydust
except
select partnum, descrip, automake from south

select partnum, descrip, automake from mydust
intersect
select partnum, descrip, automake from south


select * from employee
select * from absent

select id from employee
except
select id from absent

select descrip, sum(quantity) as total_qty
from mydust
group by descrip with rollup
--groups totals


--p 39
select descrip, quantity
from mydust
union
select rtrim(descrip) + ' TOTAL', sum(quantity)
from mydust
group by descrip
union
select 'TOTAL TOTAL', sum(quantity) from mydust
order by descrip

--rollup - display subtotals and grand totals in same result set

--cube -cross index at bottom that shows subtotals at bottom also




